/*
 * Альтернативная библиотека для управления серводвигателями. Данная библиотека отличатеся от <servo.h> отсутсвием управления сервоприводами "в фоне",
 * в данном случае чтобы сервоприводы работали надо постоянно вызывать процедуру ServoUpdate(). Но в отличие от <servo.h> моя библиотека не "отключает"
 * пины SPI протокола, что иногда очень необходимо.
 * 
 * изменено 08.06.2021
 * Бакай Егор
 * https://github.com/Ni3nayka/arduino_motor
 */


#include <using_servo.h>                // подключение библиотеки (принцип работы почти такой-же, как и <servo.h>)

const int pin = 9;
ServoMotor test_servo(pin);             // инициализация серводвигателя, названного "test_servo", который находится на порте D9

void setup() {                          // установка
  Serial.begin(9600);                   // открытие монитора порта
  test_servo.write(90);                 // установка, на какой градус повернуться серводвигателю
  test_servo.writeMicroseconds(1600);   // установка в микросекундах, как повернуться серводвигателю
  Serial.println(test_servo.read());    // вывод в монитор порта последнее введенное значение (в градусах)
  //print_servo_data();                 // вывод информации в монитор порта обо всех сервомоторах
}

void loop() {                           // тело основного цикла
  ServoUpdate();                        // процедура для обновления серводвигателей, должна находится в рабочем цикле программы (основное отличие от <servo.h>),
}                                       // если этого не сделать, то серводвигатели отключатся (до повторного вызова этой процедуры).
                                        // эта процедура активирует все серводвигатели, которые были инициализированы

/*
// альтернативный вариант управления серводвигателем: каждым приводом мы управляем напрямую
const int pin = 9;
int angle = 90;
void setup() {
  pinMode(pin, OUTPUT);
}
void loop() {
  ServoMotor_my_write(pin, angle);
}
 */
